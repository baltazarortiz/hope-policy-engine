#!/usr/bin/env python3

import os
import tempfile
import sys
import subprocess
import struct
import argparse
import random
import logging

from elftools.elf.elffile import ELFFile
from elftools.elf.constants import SH_FLAGS
from elftools.elf.sections import SymbolTableSection
from collections import defaultdict

md_range = 'md_range'
md_code = 'md_code'

PTR_SIZE = 4


class RangeFile:
    def __init__(self):
        self.file = tempfile.NamedTemporaryFile(mode='a', delete = False, prefix='ranges_');

    def write_range(self, start, end, tag):
        self.file.write('0x%x 0x%x %s\n' % (start, end, tag))

    def finish(self):
        self.file.close();

    def name(self):
        if self.file is None:
             raise Exception('file does not exist')
        return self.file.name

    def done(self):
        if self.file is not None:
             try:
                  os.remove(self.file.name)
                  self.file = None
             except:
                  pass

    def print(self):
        logging.debug(self.file.name)
        with open(self.file.name, 'r') as f:
            for l in f.readlines():
                logging.debug(l)

    def print_file(self, file_name):
        with open(file_name, 'w') as perm_file:
            with open(self.file.name, 'r') as f:
                for l in f.readlines():
                    perm_file.write(l)

    def __del__(self):
        self.done()

class RangeMap:
    def __init__(self):
        self.range_map = []

    def __contains__(self, key):
        start, end, tags = key
        return any(start >= s and end <= e for s, e, t in self.range_map)

    def __getitem__(self, index):
        return self.range_map[index]

    def sort(self):
        self.range_map = sorted(self.range_map)

    def add_range(self, start, end, tag=None):
        for curr_start, curr_end, tags in self.range_map:
            if curr_start == start and curr_end == end:
                tags.append(tag)
                return

        self.range_map.append((start, end, [tag]))

    def merge_ranges(self):
        rangemap = sorted(self.range_map)
        curr_s, curr_e, curr_tags = rangemap[0]
        for i, (s, e, tags) in enumerate(rangemap[1:], start=1):
            if s > curr_s:
                if e > curr_e:
                    rangemap[i-1] = (curr_s, s - 1, curr_tags)
                    rangemap[i] = (s, curr_e, curr_tags + tags)
                    rangemap.insert(i+1, (curr_e + 1, e, tags))
                else:
                    rangemap[i-i] = (curr_s, e, curr_tags + tags)
                    rangemap[i] = (e + 1, curr_e, curr_tags)
            elif s == curr_s:
                if e == curr_e:
                    rangemap[i-1] = (s, e, curr_tags + tags)
                    del rangemap[i]
                else:
                    rangemap[i-1] = (curr_s, curr_e, curr_tags + tags)
                    rangemap[i] = (curr_e + 1, e, tags)
            curr_s, curr_e, curr_tags = rangemap[i]

    def get_tags(self, addr):
        for curr_range, tags in self.range_map.items():
            (curr_start, curr_end) = curr_range
            if (addr >= curr_start and addr < curr_end):
                return tags
        return []

    def get_ranges(self, tag):
        return [curr_range for curr_range, tags in self.range_map.items()
                if tag in tags or (not tag and len(tags) == 0)]


RWX_X = 'Require.Tools.Elf.Section.SHF_EXECINSTR'
RWX_R = 'Require.Tools.Elf.Section.SHF_ALLOC'
RWX_W = 'Require.Tools.Elf.Section.SHF_WRITE'

CFI = 'Require.dover.Tools.GCC.CFI_Target'
NoCFI = 'Require.dover.Tools.GCC.NoCFI'

metadata_ops = {
    "DMD_SET_BASE_ADDRESS_OP": 0x01,
    "DMD_TAG_ADDRESS_OP": 0x02,
    "DMD_TAG_ADDRESS_RANGE_OP": 0x03,
    "DMD_TAG_POLICY_SYMBOL": 0x04,
    "DMD_TAG_POLICY_RANGE": 0x05,
    "DMD_TAG_POLICY_SYMBOL_RANKED": 0x06,
    "DMD_TAG_POLICY_RANGE_RANKED": 0x07,
    "DMD_END_BLOCK": 0x08,
    "DMD_END_BLOCK_WEAK_DECL_HACK": 0x09
}

tag_specifiers = {
    "DMT_CFI3L_VALID_TGT": 0x01,
    "DMT_STACK_PROLOGUE_AUTHORITY": 0x02,
    "DMT_STACK_EPILOGUE_AUTHORITY": 0x03
}

policy_map = {
    "cfi": {
        "target": {
            "tag_specifier": tag_specifiers["DMT_CFI3L_VALID_TGT"],
            "policy_name": "Require.dover.Tools.GCC.CFI_Target"
        }
    },
    "stack": {
        "prologue": {
            "tag_specifier": tag_specifiers["DMT_STACK_PROLOGUE_AUTHORITY"],
            "policy_name": "Require.dover.Tools.GCC.Prologue"
        },
        "epilogue": {
            "tag_specifier": tag_specifiers["DMT_STACK_EPILOGUE_AUTHORITY"],
            "policy_name": "Require.dover.Tools.GCC.Epilogue"
        }
    }
}


def generate_rwx_ranges(ef, range_file):
    for s in ef.iter_sections():
        flags = s['sh_flags']
        start = s['sh_addr']
        end = start + s['sh_size']
        if start == end:
            end += 4
        if flags & SH_FLAGS.SHF_EXECINSTR:
            range_file.write_range(start, end, RWX_X)
            range_file.write_range(start, end, RWX_R)
            logging.info('X {0}: 0x{1:X}'.format(s.name, start))
        elif flags & SH_FLAGS.SHF_WRITE:
            range_file.write_range(start, end, RWX_W)
            logging.info('W {0}: 0x{1:X}'.format(s.name, start))
        elif flags & SH_FLAGS.SHF_ALLOC:
            range_file.write_range(start, end, RWX_R)
            logging.info('R {0}: 0x{1:X}'.format(s.name, start))


def bytes_to_uint(it, size):
    data = []
    for _ in range(size):
        data.append(next(it))
    return int.from_bytes(data, byteorder='little', signed=False)


def round_up(x, align):
    return ~((~x) & ~align)


def add_code_section_ranges(ef, range_map):
    for s in ef.iter_sections():
        flags = s['sh_flags']
        if (flags & SH_FLAGS.SHF_ALLOC):
            start = s['sh_addr']
            end = start + s['sh_size']
            end = round_up(end, PTR_SIZE)
            if ((flags & (SH_FLAGS.SHF_ALLOC | SH_FLAGS.SHF_WRITE | SH_FLAGS.SHF_EXECINSTR)) ==
                (SH_FLAGS.SHF_ALLOC | SH_FLAGS.SHF_EXECINSTR)):
                range_map.add_range(start, end)


def parse_asm_symbols(ef, range_file):
    section = ef.get_section_by_name('.symtab')
    if isinstance(section, SymbolTableSection):
        for symbol in section.iter_symbols():
            if symbol.entry['st_size'] == 0 and symbol.entry['st_name'] != 0:
                shndx = symbol.entry['st_shndx']
                if shndx == "SHN_ABS" or shndx == "SHN_UNDEF" or shndx == "SHN_COMMON":
                    continue
                # else:
                #     symsec = ef.get_section(shndx)
                #     base_address = symsec['sh_addr']
                # address = base_address + symbol.entry['st_value']
                address = symbol.entry['st_value']
                logging.debug(symbol.name + "addr=" + hex(address))
                range_file.write_range(address, address + PTR_SIZE, CFI)


def check_and_write_range(range_file, start, end, tag_specifier,
                          policy, range_map=None):
    policy_mappings = policy_map[policy]
    for policy, tags in policy_mappings.items():
        if tags['tag_specifier'] == tag_specifier:
            range_file.write_range(start, end, tags['policy_name'])
            if range_map:
                range_map.add_range(start, end, tags['policy_name'])


def generate_policy_ranges(ef, range_file, policy):
    metadata = ef.get_section_by_name(".dover_metadata").data()
    assert metadata[0] == metadata_ops['DMD_SET_BASE_ADDRESS_OP'], "Invalid metadata found in ELF file!"

    it = iter(metadata)

    if policy == "cfi":
        range_map = RangeMap()
    else:
        range_map = None

    for byte in it:
        if (byte == metadata_ops['DMD_SET_BASE_ADDRESS_OP']):
            base_address = bytes_to_uint(it, 8) #apparently GCC emits a 64-bit base
            logging.debug("new base address is " + hex(base_address) + "\n")
        elif (byte == metadata_ops['DMD_TAG_ADDRESS_OP']):
            address = bytes_to_uint(it, PTR_SIZE) + base_address
            tag_specifier = bytes_to_uint(it, 1)
            logging.debug("tag is " + hex(tag_specifier) +
                          " at address " + hex(address) + '\n')

            check_and_write_range(range_file, address, address + PTR_SIZE, tag_specifier,
                                  policy, range_map)

        elif (byte == metadata_ops['DMD_TAG_ADDRESS_RANGE_OP']):
            start_address = bytes_to_uint(it, PTR_SIZE) + base_address
            end_address = bytes_to_uint(it, PTR_SIZE) + base_address
            tag_specifier = bytes_to_uint(it, 1)
            logging.debug("tag is " + hex(tag_specifier) +
                          " for address range " +
                          hex(start_address) + ":" + hex(end_address) + '\n')

            check_and_write_range(range_file, start_address, end_address, tag_specifier,
                                  policy, range_map)

        elif (byte == metadata_ops['DMD_TAG_POLICY_SYMBOL']):
            logging.critical("Saw policy symbol!\n")
            sys.exit(-1)
        elif (byte == metadata_ops['DMD_TAG_POLICY_RANGE']):
            logging.critical("Saw policy range!\n")
            sys.exit(-1)
            for _ in range(PTR_SIZE*3):
                #skip start, end, & 32-bit tag-type
                next(it)
        elif (byte == metadata_ops['DMD_TAG_POLICY_SYMBOL_RANKED']):
            logging.critical("Saw policy symbol ranked\n")
            sys.exit(-1)
        elif (byte == metadata_ops['DMD_TAG_POLICY_RANGE_RANKED']):
            sys.exit(-1)
            logging.critical("Saw policy symbol range ranked\n")
            #skip start, end ,tag category, rank, tag type
            for _ in range(PTR_SIZE*5):
                next(it)
        elif (byte == metadata_ops['DMD_END_BLOCK_WEAK_DECL_HACK']):
            logging.critical("saw end weak decl tag!\n")
            sys.exit(-1)
        elif (byte == metadata_ops['DMD_END_BLOCK']):
            #need extra word here to tag last instruction since end_address is the address of last instruction
            end_address = bytes_to_uint(it, PTR_SIZE) + PTR_SIZE
            logging.debug("saw end block tag range = " + hex(base_address) +
                          ":" + hex(base_address + end_address))
            if range_map:
                range_map.add_range(base_address, base_address + end_address, "COMPILER_GENERATED")
        else:
            logging.debug("Error: found unknown byte in metadata!" + hex(byte) + "\n")
            sys.exit(-1)

    return range_map


def generate_cfi_ranges(ef, range_file):
    code_range_map = RangeMap()
    add_code_section_ranges(ef, code_range_map)
    range_map = generate_policy_ranges(ef, range_file, "cfi")

    for (start, end, tags) in code_range_map:
        for s in range(start, end, PTR_SIZE):
            e = s + PTR_SIZE
            if (s, e, tags) not in range_map:
                range_file.write_range(s, e, NoCFI)


def write_section_range(ef, range_file, section_name, tag):
    section = ef.get_section_by_name("." + section_name)
    if not section:
        logging.fatal("Couldn't find section {} in elf file!".format(section_name))
    start = section['sh_addr']
    end = start + section['sh_size']
    range_file.write_range(start, end, tag)


def generate_stack_ranges(ef, range_file):
    generate_policy_ranges(ef, range_file, "stack")


def main():
    parser = argparse.ArgumentParser(description='Generate tag ranges file from ELF binary',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-d", "--policy-dir", action="store", required=True,
                        help="Directory with generated policy yaml")
    parser.add_argument("-t", "--tag-file", action="store", required=True,
                        help="File to output tag info")
    parser.add_argument("-b", "--bin", action="store", required=True,
                        help="Program binary to parse for tags")
    parser.add_argument("-p", "--policies", action="store", required=True,
                        help="Policy string to generate tags for (e.g. osv.frtos.main.cfi-rwx))")
    parser.add_argument("--log", action="store", default='WARNING',
                        help="Logging level (DEBUG, WARNING, INFO)")

    args = parser.parse_args()

    numeric_level = getattr(logging, args.log.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log)
    logging.basicConfig(level=numeric_level, stream=sys.stderr)

    try:
        os.remove(args.tag_file)
    except OSError as err:
        print('could not remove ' + args.tag_file)

    with open(args.bin, 'rb') as f:
        ef = ELFFile(f)

        range_file = RangeFile()

        policies = args.policies.split('.')[-1].split('-')

        for policy in policies:
            generate_ranges_func = 'generate_' + policy + '_ranges'
            logging.info("Generating tags for policy {}".format(policy))
            if generate_ranges_func in globals() and callable(globals()[generate_ranges_func]):
                globals()[generate_ranges_func](ef, range_file)
            else:
                raise KeyError('No such policy generation function: ' + generate_ranges_func)

        range_file.finish();
        # range_file.print()
        #     proc = subprocess.Popen([md_range, policy_dir, base_address_string, range_file.name(), taginfo_file_name])
        proc = subprocess.Popen([md_range, args.policy_dir, range_file.name(), args.tag_file])
        proc.wait()
        range_file.done()

        # tag the code for group tags
        for s in ef.iter_sections():
            if s['sh_flags'] & SH_FLAGS.SHF_EXECINSTR:
                section_addr_string = '0x{:08x}'.format(s['sh_addr'])
                proc = subprocess.Popen([md_code,
                                         args.policy_dir,
                                         #base_address_string,
                                         section_addr_string,
                                         args.tag_file],
                                        stdin=subprocess.PIPE,
                )
                proc.communicate(s.data())
                proc.wait()

if (__name__ == "__main__"):
    main()
